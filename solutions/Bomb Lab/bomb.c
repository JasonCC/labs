//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2015 Retargetable Decompiler <info@retdec.com>
//

#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* ------------- Structures ------------- */

struct _IO_FILE {
    struct _IO_FILE * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int16_t e4;
    char e5;
    char e6[1];
    int32_t * e7;
    int64_t e8;
    int32_t e9[16];
};

struct _struct__IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _struct__IO_marker * e12;
    struct _struct__IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    int32_t e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    int32_t e28[40];
};

struct _struct__IO_marker {
    struct _struct__IO_marker * e0;
    struct _struct__IO_FILE * e1;
    int32_t e2;
};

struct struct_1 {
    char e0;
    char e1[2];
};

/* -------- Function Prototypes --------- */

void phase_1(void);
void phase_2(void);
void phase_3(void);
void func4(void);
void phase_4(void);
void phase_5(void);
void phase_6(void);
void sig_handler(void);
void read_six_numbers(void);
void string_length(void);
void strings_not_equal(void);
void initialize_bomb(void);
void blank_line(void);
void skip(void);
void read_line(void);
void explode_bomb(void);
void phase_defused(void);

/* ---------- Global Variables ---------- */

int32_t g1 = 0; // 0x804b480
int32_t g2 = 0; // 0x804b640
int32_t g3 = 0; // 0x804b644
int32_t g4 = 0; // 0x804b648
int32_t g5 = 0; // gpr0
int32_t g6 = 0; // gpr3
int32_t g7 = 0; // gpr6
struct _IO_FILE * infile; // 0x804b664

/* ------------- Functions -------------- */

// From module:   /usr0/droh/213/private/L2/src/bomb.c
// Address range: 0x80489b0 - 0x8048b1f
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv; // 0x80489ba_1
    g6 = v1;
    if ((char *)argc == (char *)1) {
        // 0x80489c2
        infile = (struct _IO_FILE *)g4;
        // branch -> 0x8048a30
        // 0x8048a30
        initialize_bomb();
        printf("Welcome to my fiendish little bomb. You have 6 phases with\n");
        printf("which to blow yourself up. Have a nice day!\n");
        read_line();
        phase_1();
        phase_defused();
        printf("Phase 1 defused. How about the next one?\n");
        read_line();
        phase_2();
        phase_defused();
        printf("That's number 2.  Keep going!\n");
        read_line();
        phase_3();
        phase_defused();
        printf("Halfway there!\n");
        read_line();
        phase_4();
        phase_defused();
        printf("So you got that one.  Try this one.\n");
        read_line();
        phase_5();
        phase_defused();
        printf("Good work!  On to the next...\n");
        read_line();
        phase_6();
        phase_defused();
        return 0;
    }
    // 0x80489d0
    if (argc != 2) {
        int32_t v2 = *(int32_t *)argv; // bp-72
        printf("Usage: %s [<input_file>]\n", &v2);
        exit(8);
        // UNREACHABLE
    }
    int32_t v3 = (int32_t)"r";
    int32_t v4 = *(int32_t *)(v1 + 4);
    struct _struct__IO_FILE * file = fopen((char *)&v4, "r"); // 0x80489e1
    infile = (struct _IO_FILE *)file;
    if (file == NULL) {
        int32_t v5 = *(int32_t *)(g6 + 4); // bp-36
        v3 = *(int32_t *)g6;
        v4 = (int32_t)"%s: Error: Couldn't open %s\n";
        printf("%s: Error: Couldn't open %s\n", &v3, &v5);
        exit(8);
        // UNREACHABLE
    }
    // 0x8048a30
    initialize_bomb();
    printf("Welcome to my fiendish little bomb. You have 6 phases with\n");
    printf("which to blow yourself up. Have a nice day!\n");
    read_line();
    phase_1();
    phase_defused();
    printf("Phase 1 defused. How about the next one?\n");
    read_line();
    phase_2();
    phase_defused();
    printf("That's number 2.  Keep going!\n");
    read_line();
    phase_3();
    phase_defused();
    printf("Halfway there!\n");
    read_line();
    phase_4();
    phase_defused();
    printf("So you got that one.  Try this one.\n");
    read_line();
    phase_5();
    phase_defused();
    printf("Good work!  On to the next...\n");
    read_line();
    phase_6();
    phase_defused();
    return 0;
}

// Address range: 0x8048b20 - 0x8048b47
void phase_1(void) {
    // 0x8048b20
    strings_not_equal();
    if (g5 != 0) {
        // 0x8048b3e
        explode_bomb();
        // branch -> 0x8048b43
    }
}

// Address range: 0x8048b48 - 0x8048b97
void phase_2(void) {
    // 0x8048b48
    read_six_numbers();
    int32_t v1;
    if (v1 != 1) {
        // 0x8048b69
        explode_bomb();
        // branch -> 0x8048b6e
    }
    int32_t v2 = 1;
    int32_t v3 = 1; // 0x8048b76
    // branch -> 0x8048b76
    while (true) {
        int32_t v4 = v3; // 0x8048b88
        int32_t v5;
        if (v1 != (v3 + 1) * v5) {
            // 0x8048b83
            explode_bomb();
            v4 = v2;
            // branch -> 0x8048b88
        }
        int32_t v6 = v4 + 1; // 0x8048b88
        v2 = v6;
        if (v6 >= 6) {
            // break -> 0x8048b8e
            break;
        }
        v3 = v6;
        // continue -> 0x8048b76
    }
}

// Address range: 0x8048b98 - 0x8048c9f
void phase_3(void) {
    int32_t v1 = g6; // 0x8048b9e
    char * str;
    int32_t v2;
    int32_t v3;
    char v4;
    if (sscanf(str, "%d %c %d", &v2, &v4, &v3) <= 2) {
        // 0x8048bc4
        explode_bomb();
        // branch -> 0x8048bc9
    }
    // 0x8048bc9
    switch (v2) {
        default: {
            // 0x8048c88
            explode_bomb();
            // branch -> 0x8048c8f
            break;
        }
        case 0: {
            // 0x8048be0
            if (v3 != 777) {
                // 0x8048bef
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g6 & -256 || 113) != (int32_t)v4) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g6 = v1;
            return;
        }
        case 1: {
            // 0x8048c00
            if (v3 != 214) {
                // 0x8048c0f
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g6 & -256 || 98) != (int32_t)v4) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g6 = v1;
            return;
        }
        case 2: {
            // 0x8048c16
            if (v3 != 755) {
                // 0x8048c21
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g6 & -256 || 98) != (int32_t)v4) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g6 = v1;
            return;
        }
        case 3: {
            // 0x8048c28
            if (v3 != 251) {
                // 0x8048c33
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g6 & -256 || 107) != (int32_t)v4) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g6 = v1;
            return;
        }
        case 4: {
            // 0x8048c40
            if (v3 != 160) {
                // 0x8048c4b
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g6 & -256 || 111) != (int32_t)v4) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g6 = v1;
            return;
        }
        case 5: {
            // 0x8048c52
            if (v3 != 458) {
                // 0x8048c5d
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g6 & -256 || 116) != (int32_t)v4) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g6 = v1;
            return;
        }
        case 6: {
            // 0x8048c64
            if (v3 != 780) {
                // 0x8048c6f
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g6 & -256 || 118) != (int32_t)v4) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g6 = v1;
            return;
        }
        case 7: {
            // 0x8048c76
            if (v3 != 524) {
                // 0x8048c81
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g6 & -256 || 98) != (int32_t)v4) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g6 = v1;
            return;
        }
    }
    // 0x8048c8f
    if ((g6 & -256 || 120) != (int32_t)v4) {
        // 0x8048c94
        explode_bomb();
        // branch -> 0x8048c99
    }
    // 0x8048c99
    g6 = v1;
}

// Address range: 0x8048ca0 - 0x8048cdd
void func4(void) {
    int32_t v1 = g7; // 0x8048ca6
    int32_t v2 = g6; // 0x8048ca7
    uint32_t v3;
    g6 = v3;
    int32_t v4;
    if (v3 >= 2) {
        // 0x8048cb0
        func4();
        g7 = g5;
        func4();
        v4 = g7 + g5;
        // branch -> 0x8048cd5
    } else {
        v4 = 1;
    }
    // 0x8048cd5
    g5 = v4;
    g6 = v2;
    g7 = v1;
}

// Address range: 0x8048ce0 - 0x8048d2b
void phase_4(void) {
    char * str;
    char * v1;
    if (sscanf(str, "%d", &v1) != 1 || v1 <= NULL) {
        // 0x8048d09
        explode_bomb();
        // branch -> 0x8048d0e
    }
    // 0x8048d0e
    func4();
    if (g5 != 55) {
        // 0x8048d22
        explode_bomb();
        // branch -> 0x8048d27
    }
}

// Address range: 0x8048d2c - 0x8048d94
void phase_5(void) {
    int32_t v1 = g7; // 0x8048d32
    int32_t v2 = g6; // 0x8048d33
    char * v3;
    g6 = (int32_t)*v3;
    string_length();
    if (g5 != 6) {
        // 0x8048d48
        explode_bomb();
        // branch -> 0x8048d4d
    }
    int32_t v4 = 0;
    g7 = 0x804b220;
    int32_t v5 = 0x804b220; // 0x8048d5f
    int32_t v6 = 0;
    // branch -> 0x8048d57
    while (true) {
        unsigned char v7 = v3[v6]; // 0x8048d57
        unsigned char v8 = *(char *)((int32_t)(v7 % 16) + v5); // 0x8048d5f
        NULL[v6] = v8;
        int32_t v9 = v4 + 1; // 0x8048d65
        v4 = v9;
        if (v9 >= 6) {
            // 0x8048d6b
            strings_not_equal();
            if (g5 != 0) {
                // 0x8048d87
                explode_bomb();
                // branch -> 0x8048d8c
            }
            // 0x8048d8c
            g6 = v2;
            g7 = v1;
            return;
        }
        // 0x8048d57
        v5 = g7;
        v6 = v9;
        // branch -> 0x8048d57
    }
}

// Address range: 0x8048d98 - 0x8048e90
void phase_6(void) {
    read_six_numbers();
    int32_t v1 = 0;
    int32_t v2 = 0; // 0x8048dd12
    // branch -> 0x8048dc0
    int32_t * v3;
    while (true) {
        int32_t v4 = v2; // 0x8048dd9
        if (*v3 >= 7) {
            // 0x8048dcc
            explode_bomb();
            v4 = v1;
            // branch -> 0x8048dd1
        }
        int32_t v5 = v4 + 1; // 0x8048dd1
        int32_t v6 = v5;
        int32_t v7; // 0x8048dfc
        if (v5 <= 5) {
            // branch -> 0x8048de6
            while (true) {
                int32_t v8 = v5; // 0x8048df6
                if (*v3 == v3[1]) {
                    // 0x8048df1
                    explode_bomb();
                    v8 = v6;
                    // branch -> 0x8048df6
                }
                int32_t v9 = v8 + 1; // 0x8048df6
                v6 = v9;
                if (v9 >= 6) {
                    // break -> 0x8048dfc
                    break;
                }
                v5 = v9;
                // continue -> 0x8048de6
            }
            // 0x8048dfc
            v7 = v1 + 1;
            v1 = v7;
            if (v7 >= 6) {
                // break -> 0x8048e02
                break;
            }
            v2 = v7;
            // continue -> 0x8048dc0
            continue;
        }
        // 0x8048dfc
        v7 = v1 + 1;
        v1 = v7;
        if (v7 >= 6) {
            // break -> 0x8048e02
            break;
        }
        v2 = v7;
        // continue -> 0x8048dc0
    }
    // 0x8048e02
    v1 = 0;
    int32_t v10 = 0;
    // branch -> 0x8048e10
    while (true) {
        int32_t ** v11 = (int32_t **)0x804b26c;
        uint32_t v12 = *v3; // 0x8048e21
        int32_t v13 = (int32_t)*v11; // 0x8048e3b
        int32_t v14; // 0x8048e3e
        int32_t * v15;
        if (v12 >= 2) {
            int32_t v16 = 1; // 0x8048e33
            // branch -> 0x8048e30
            while (v16 + 1 != v12) {
                // 0x8048e30
                v16++;
                // continue -> 0x8048e30
            }
            // 0x8048e38
            v15[v10] = (int32_t)*v11;
            v14 = v1 + 1;
            v1 = v14;
            if (v14 >= 6) {
                // break -> 0x8048e44
                break;
            }
            v10 = v14;
            // continue -> 0x8048e10
            continue;
        }
        // 0x8048e38
        v15[v10] = v13;
        v14 = v1 + 1;
        v1 = v14;
        if (v14 >= 6) {
            // break -> 0x8048e44
            break;
        }
        v10 = v14;
        // continue -> 0x8048e10
    }
    // 0x8048e44
    int32_t v17;
    int32_t ** v18 = (int32_t **)v17; // bp-56
    *(int32_t *)(v17 + 8) = v17;
    int32_t v19 = 2; // 0x8048e5a
    // branch -> 0x8048e52
    while (v19 < 6) {
        // 0x8048e52
        *(int32_t *)(v17 + 8) = v17;
        v19++;
        // continue -> 0x8048e52
    }
    // 0x8048e60
    *(int32_t *)(v17 + 8) = 0;
    v1 = 0;
    int32_t v20 = 0; // 0x8048e8110
    int32_t v21 = (int32_t)*v18; // 0x8048e73
    int32_t ** v22 = v18;
    // branch -> 0x8048e70
    while (true) {
        int32_t * v23 = *v22; // 0x8048e75
        int32_t v24 = v20; // 0x8048e81
        int32_t * v25 = v23; // 0x8048e7e
        int32_t ** v26 = v22;
        if (*(int32_t *)v21 < (int32_t)v23) {
            // 0x8048e79
            explode_bomb();
            v24 = v1;
            v25 = *v18;
            v26 = v18;
            // branch -> 0x8048e7e
        }
        int32_t v27 = v24 + 1; // 0x8048e81
        v1 = v27;
        if (v27 >= 5) {
            // break -> 0x8048e87
            break;
        }
        v20 = v27;
        v21 = (int32_t)v25;
        v22 = v26;
        // continue -> 0x8048e70
    }
}

// Address range: 0x8048f50 - 0x8048fad
void sig_handler(void) {
    // 0x8048f50
    printf("So you think you can stop the bomb with ctrl-c, do you?\n");
    sleep(3);
    printf("Well...");
    int32_t v1 = g2; // bp-44
    fflush((struct _struct__IO_FILE *)&v1);
    sleep(1);
    v1 = (int32_t)"OK. :-)\n";
    printf("OK. :-)\n");
    exit(16);
    // UNREACHABLE
}

// Address range: 0x8048fd8 - 0x8049014
void read_six_numbers(void) {
    // 0x8048fd8
    char * v1;
    int32_t v2 = (int32_t)v1; // 0x8048fe1
    char * v3 = (char *)(v2 + 16); // bp-20
    char * v4 = (char *)(v2 + 12); // bp-24
    char * v5 = (char *)(v2 + 8); // bp-28
    char * v6 = (char *)(v2 + 4); // bp-32
    char * str;
    uint32_t items_assigned = sscanf(str, "%d %d %d %d %d %d", &v1, &v6, &v5, &v4, &v3, (int32_t *)(v2 + 20)); // 0x8048fff
    if (items_assigned <= 5) {
        // 0x804900c
        explode_bomb();
        // branch -> 0x8049011
    }
}

// Address range: 0x8049018 - 0x804902f
void string_length(void) {
    struct struct_1 * v1 = NULL;
    g5 = 0;
    if (v1->e0 == 0) {
        // 0x804902c
        return;
    }
    int32_t v2 = (int32_t)v1 + 1; // 0x8049025
    int32_t v3 = 1; // 0x8049026
    g5 = v3;
    while (*(char *)v2 != 0) {
        // 0x8049025
        v2++;
        v3++;
        g5 = v3;
        // continue -> 0x8049025
    }
}

// Address range: 0x8049030 - 0x8049088
void strings_not_equal(void) {
    string_length();
    int32_t v1 = g5;
    string_length();
    if (v1 != g5) {
        // 0x804907f
        g5 = 1;
        return;
    }
    // 0x8049060
    int32_t v2;
    char v3 = *(char *)v2; // 0x8049064
    if (v3 == 0) {
        // 0x804907f
        g5 = 0;
        return;
    }
    // 0x8049070
    char * v4;
    int32_t v5 = (int32_t)*v4; // 0x8049077
    // branch -> 0x8049070
    int32_t v6;
    while (true) {
        int32_t v7 = (int32_t)v3 | v1 & -256; // 0x8049070
        if (v7 == (int32_t)v4[v5]) {
            int32_t v8 = v2 + 1; // 0x8049076
            char v9 = *(char *)v8; // 0x8049078
            if (v9 == 0) {
                v6 = 0;
                // break -> 0x804907f
                break;
            }
            v5++;
            v1 = v7;
            v3 = v9;
            v2 = v8;
            // continue -> 0x8049070
            continue;
        } else {
            v6 = 1;
        }
    }
    // 0x804907f
    g5 = v6;
}

// Address range: 0x8049160 - 0x8049178
void initialize_bomb(void) {
    // 0x8049160
    signal(SIGINT, (void (*)(int32_t))sig_handler);
}

// Address range: 0x804917c - 0x80491ad
void blank_line(void) {
    char * v1;
    int32_t v2 = (int32_t)*v1; // 0x804917f_0
    char v3 = *(char *)v2; // 0x8049182
    if (v3 == 0) {
        // 0x80491aa
        return;
    }
    int32_t v4 = v2 + 1; // 0x8049193
    // branch -> 0x8049190
    while (*(char *)(g3 + 1 + 2 * (int32_t)v3) != 32 && v1[1] != 0) {
        // 0x8049190
        // 0x80491a0
        v3 = *(char *)v4;
        v4++;
        // branch -> 0x8049190
    }
}

// Address range: 0x80491b0 - 0x80491f9
void skip(void) {
    int32_t v1 = 80 * g1 + 0x804b680; // 0x80491cd6
    if (fgets((char *)v1, 80, (struct _struct__IO_FILE *)infile) == NULL) {
        // 0x80491f1
        return;
    }
    g5 = v1;
    blank_line();
    int32_t v2 = 80 * g1 + 0x804b680; // 0x80491cd
    while (fgets((char *)v2, 80, (struct _struct__IO_FILE *)infile) != NULL) {
        // 0x80491e1
        g5 = v2;
        blank_line();
        v2 = 80 * g1 + 0x804b680;
        // continue -> 0x80491e1
    }
}

// Address range: 0x80491fc - 0x80492bc
void read_line(void) {
    // 0x80491fc
    skip();
    int32_t len; // 0x8049278
    if (g5 == 0) {
        // 0x804920c
        if ((int32_t)infile != g4) {
            // 0x8049219
            if (getenv("GRADE_BOMB") != NULL) {
                // 0x804922d
                exit(0);
                // UNREACHABLE
            }
            // 0x8049237
            infile = (struct _IO_FILE *)g4;
            skip();
            if (g5 == 0) {
                // 0x804924a
                printf("Error: Premature EOF on stdin\n");
                explode_bomb();
                // branch -> 0x804925f
            }
            // 0x804925f
            len = strlen((char *)(80 * g1 + 0x804b680));
            if (len == 79) {
                // 0x8049286
                printf("Error: Input line too long\n");
                explode_bomb();
                // branch -> 0x8049298
            }
            // 0x8049298
            *(char *)(len + 0x804b67f + 80 * g1) = 0;
            g1++;
            return;
        }
        // 0x804924a
        printf("Error: Premature EOF on stdin\n");
        explode_bomb();
        // branch -> 0x804925f
    }
    // 0x804925f
    len = strlen((char *)(80 * g1 + 0x804b680));
    if (len == 79) {
        // 0x8049286
        printf("Error: Input line too long\n");
        explode_bomb();
        // branch -> 0x8049298
    }
    // 0x8049298
    *(char *)(len + 0x804b67f + 80 * g1) = 0;
    g1++;
}

// Address range: 0x80494fc - 0x8049524
void explode_bomb(void) {
    // 0x80494fc
    printf("\nBOOM!!!\n");
    printf("The bomb has blown up.\n");
    exit(8);
    // UNREACHABLE
}

// Address range: 0x804952c - 0x80495af
void phase_defused(void) {
    if (g1 == 6) {
        int32_t v1 = 0x804b770;
        int32_t v2;
        int32_t v3;
        if (sscanf((char *)&v1, "%d %s", &v3, &v2) == 2) {
            // 0x804955b
            strings_not_equal();
            // branch -> 0x8049592
        }
        // 0x8049592
        v1 = (int32_t)"Congratulations! You've defused the bomb!\n";
        printf("Congratulations! You've defused the bomb!\n");
        // branch -> 0x804959f
    }
}

/* --------- External Functions --------- */

// void exit (int)
// int fflush (FILE *)
// char * fgets (char *restrict, int, FILE *restrict)
// FILE * fopen (const char *restrict, const char *restrict)
// char * getenv (const char *)
// int printf (const char *restrict, ...)
// sighandler_t signal(int signum, sighandler_t handler)
// unsigned int sleep (unsigned int seconds)
// int sscanf (const char *restrict, const char *restrict, ...)
// int32_t strlen(char * a1);

/* ---------- Meta-Information ---------- */

// Detected compiler: gcc 2.95.3
// Detected language: C
// Detected functions: 18 (22 in front-end)
// Decompiler release: v2.0 (Jun  1 2015)
// Decompilation date: Sep 06 2015 19:32:30
